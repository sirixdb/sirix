dependencies {
    api implLibraries.jacksonCore
    api implLibraries.brackit
    api implLibraries.jcommander
    api implLibraries.aspectjrt
    api implLibraries.slf4jApi
    api implLibraries.perfidix
    api implLibraries.xmlunit
    api implLibraries.logbackClassic
    api implLibraries.logbackCore
    api implLibraries.gson
    api implLibraries.guava
    api implLibraries.guavaTestlib
    api implLibraries.checkerFramework
    api implLibraries.caffeine
    api implLibraries.tink
    api implLibraries.dagger
    api implLibraries.fastUtil
    api implLibraries.iouring
    api implLibraries.lz4
    api implLibraries.roaringbitmap

    implementation implLibraries.snappyJava
    implementation implLibraries.browniesCollections
    implementation implLibraries.integercompression
    implementation implLibraries.fastObjectPool
    implementation implLibraries.zeroAllocationHashing

    annotationProcessor implLibraries.daggerCompiler

    testImplementation testLibraries.junitJupiterApi
    testImplementation testLibraries.junitJupiterEngine
    testImplementation testLibraries.junitJupiterParams
    testImplementation testLibraries.junitVintageEngine
    testImplementation testLibraries.junitPlatformLauncher
    testImplementation testLibraries.junitPlatformRunner
    testImplementation testLibraries.mockitoCore
    testImplementation testLibraries.byteBuddy
    testImplementation testLibraries.testng
    testImplementation testLibraries.jsonassert
    testImplementation testLibraries.commonsCollections4
    testImplementation testLibraries.commonsCollections4Tests
    testImplementation testLibraries.assertjCore
}

description = 'SirixDB is a hybrid on-disk and in-memory document oriented, versioned database system. It has a ' +
        'lightweight buffer manager, stores everything in a huge persistent and durable tree and allows efficient ' +
        'reconstruction of every revision. Furthermore, SirixDB implements change tracking, diffing and supports time travel queries.'

jar {
    manifest {
        attributes('Main-Class': 'org.sirix.utils.CommandoLineExplorer')
    }
}

test {
    useJUnitPlatform()
    
    // Add async-profiler if ASYNC_PROFILER env var is set
    // Usage: ASYNC_PROFILER=/path/to/async-profiler PROFILE_EVENT=cpu|alloc PROFILE_OUTPUT=/tmp/profile.txt ./gradlew test
    def profilerPath = System.getenv("ASYNC_PROFILER")
    def profileEvent = System.getenv("PROFILE_EVENT") ?: "cpu"
    def profileOutput = System.getenv("PROFILE_OUTPUT") ?: "/tmp/sirix-profile.html"
    
    // JFR profiling: set JFR_PROFILE=1 to enable
    def jfrProfile = System.getenv("JFR_PROFILE")
    def jfrOutput = System.getenv("JFR_OUTPUT") ?: "/tmp/sirix-flight.jfr"
    
    def baseArgs = [
        '--add-opens', 'java.base/sun.nio.ch=ALL-UNNAMED',
        '--add-opens', 'java.base/java.nio=ALL-UNNAMED',
        '--add-modules', 'jdk.incubator.vector',
        '--enable-native-access=ALL-UNNAMED',
        '-XX:+UnlockDiagnosticVMOptions',
        '-XX:+DebugNonSafepoints',
    ]

    // ZGC mode: ./gradlew test -Pzgc=true
    // Adds ZGC + performance flags from JsonShredderTest Chicago benchmark
    if (project.hasProperty('zgc')) {
        baseArgs.addAll([
            '-XX:+UseZGC',
            '-XX:+UnlockExperimentalVMOptions',
            '-XX:+AlwaysPreTouch',
            '-XX:+DisableExplicitGC',
            '-XX:ReservedCodeCacheSize=1000m',
            '-XX:EliminateAllocationArraySizeLimit=1024',
        ])
        println "ZGC mode enabled with performance flags"
    }
    
    if (profilerPath) {
        baseArgs.add("-agentpath:${profilerPath}/lib/libasyncProfiler.so=start,event=${profileEvent},file=${profileOutput}")
        println "Async-profiler enabled: event=${profileEvent}, output=${profileOutput}"
    }
    
    if (jfrProfile) {
        baseArgs.add("-XX:StartFlightRecording=duration=120s,filename=${jfrOutput},settings=profile")
        println "JFR profiling enabled: output=${jfrOutput}"
    }

    // GC logging: set GC_LOG env var to enable
    // Usage: GC_LOG=/tmp/gc.log ./gradlew test -Pzgc ...
    def gcLog = System.getenv("GC_LOG")
    if (gcLog) {
        baseArgs.add("-Xlog:gc,gc+heap=info:file=${gcLog}:time,uptime,level,tags")
        println "GC logging enabled: output=${gcLog}"
    }

    jvmArgs = baseArgs

    // Allow overriding @Disabled annotations for manual/profiling tests
    // Usage: ./gradlew test -PdisableConditions=true --tests "...profileAsyncAutoCommit"
    if (project.hasProperty('disableConditions')) {
        systemProperty "junit.jupiter.conditions.deactivate", "org.junit.*DisabledCondition"
    }

    // Pass through diagnostic system properties
    systemProperty "sirix.debug.path.summary", System.getProperty("sirix.debug.path.summary", "false")
    systemProperty "sirix.debug.leak.diagnostics", System.getProperty("sirix.debug.leak.diagnostics", "false")
    systemProperty "sirix.debug.memory.leaks", System.getProperty("sirix.debug.memory.leaks", "false")
    systemProperty "sirix.debug.pin.counts", System.getProperty("sirix.debug.pin.counts", "false")
    
    // LZ4 decompression mode: safe mode is actually faster in LZ4 1.9.x
    // Fast mode was deprecated and may be slower due to internal safety checks
    // Enable fast mode (for testing only): ./gradlew test -Plz4.fast=true
    def useFastLz4 = project.hasProperty('lz4.fast')
    systemProperty "sirix.lz4.fast.decompress", useFastLz4.toString()
    
    // Show test output for diagnostics
    testLogging {
        showStandardStreams = true
        exceptionFormat = 'full'
    }
}
